{
  "name": "Iterative-avgstd",
  "tagline": "Iterative calculation of mean and standard deviation with low resources",
  "body": "# iterative-avgstd\r\nIterative calculation of mean and standard deviation\r\n\r\nI have developed this tiny library to calculate simple statistics on analog samplings for my Arduino project without the need to store the whole amount of data. Details on the algorithm in the docs folder.\r\n\r\n\r\n\r\n## Here is how it started...   \r\nSome time ago I was sick with some fever. The only thing I could do was to lay in bed. I took an electronic thermometer and measured my temperature, say 37.8C. It took so little time that I tried again, 37.4C. I tried a third time and the temperature kept changing. \r\nI thought to measure a few times and then to calculate the average, to see a more stable result. \r\n\r\nAfter a few sampling, doing it by heart without a piece of paper starts to be a bit complex. I started thinking that there must be a way to use the latest measured average and update it with the next sample.\r\n\r\nI worked out a simple formula:\r\n\r\n<T>_N = 1/N * sum_i^N T_i \r\n<T>_(N+1) = 1/(N+1) * sum_i^(N+1) T_i = 1/(N+1) * ( sum_i^N T_i + T_(N+1))\r\n\r\n<T>_(N+1) = N/(N+1) * <T>_N + T_(N+1)/(N+1) \r\n\r\nSo the next average can be calculated by keeping in mind only 3 numbers: the average, the number of samplings and the last sample. That's nice!\r\nI worked out also the rule for the standard deviation, or better for the variance. \r\n\r\nvar_(N+1) = var_N * ((N-1)/N) + (T_(N+1) - <T>_N)^2 \r\n\r\nHere, you need to remember only 4 numbers, the average, the variance, the sample and the number of samplings.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}